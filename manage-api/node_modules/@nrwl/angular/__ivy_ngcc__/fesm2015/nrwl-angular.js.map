{"version":3,"file":"nrwl-angular.js","sources":["../../src/runtime/nx/data-persistence.ts","../../src/runtime/nx/nx.module.ts","../../nrwl-angular.ts"],"names":[],"mappings":";;;;;;;;;;SAoDgB,iBAAiB,CAC/B,IAAiC;AAChC,IACD,OAAO,CAAC,MAA+B;AAAO,QAC5C,OAAO,MAAM,CAAC,IAAI,CAChB,iBAAiB,EAAE,EACnB,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CACxD,CAAC;AACN,KAAG,CAAC;AACJ,CAAC;AACD,SACgB,gBAAgB,CAC9B,IAAgC;AAC/B,IACD,OAAO,CAAC,MAA+B;AAAO,QAC5C,OAAO,MAAM,CAAC,IAAI,CAChB,iBAAiB,EAAE,EACnB,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAC3D,CAAC;AACN,KAAG,CAAC;AACJ,CAAC;AACD,SACgB,KAAK,CAAsB,IAAqB;AAChE,IAAE,OAAO,CAAC,MAA+B;AAAO,QAC5C,IAAI,IAAI,CAAC,EAAE,EAAE;AACjB,YAAM,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAChC,iBAAiB,EAAE,EACnB,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC;AAChC,gBAAU,OAAO,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AACxC,aAAS,CAAC,CACH,CAAC;AACR,YACM,OAAO,cAAc,CAAC,IAAI,CACxB,QAAQ,CAAC,CAAC,KAAK,KACb,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CACpE,CACF,CAAC;AACR,SAAK;AACL,QACI,OAAO,MAAM,CAAC,IAAI,CAChB,iBAAiB,EAAE,EACnB,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CACxD,CAAC;AACN,KAAG,CAAC;AACJ,CAAC;AACD,SACgB,UAAU,CACxB,SAAoB,EACpB,IAA6B;AAC5B,IACD,OAAO,CAAC,MAA+B;AACzC,QAAI,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CACrB,iBAAiB,EAAE,EACnB,MAAM,CAAC,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK,eAAe,CAAC,MAAM,CAAC,CAAC,EACpD,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC;AAC1B,YAAQ,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE;AACtC;AACM;AACM,gBAAF,OAAO;AACjB,aAAS;AACT,YACQ,OAAO;AACf,gBAAU,YAAY,CAAC,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC;AAClE,gBAAU,KAAK;AACf,aAAwC,CAAC;AACzC,SAAO,CAAC,EACF,MAAM,CAAC,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,CAC1C,CAAC;AACN,QACI,OAAO,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AAC7E,KAAG,CAAC;AACJ,CAAC;AAED,SAAS,eAAe,CACtB,MAAW;AACV,IACD,OAAO,MAAM,CAAC,IAAI,KAAK,iBAAiB,CAAC;AAC3C,CAAC;AAED,SAAS,oBAAoB,CAC3B,GAAkD,EAClD,OAAY;AACX,IACD,OAAO,CAAC,CAAC,MAAM,EAAE,KAAK,CAAS;AAAO,QACpC,IAAI;AACR,YAAM,MAAM,CAAC,GAAG,kBAAkB,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;AACvD,YAAM,OAAO,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,kBAAkB,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/E,SAAK;AAAC,QAAA,OAAO,CAAC,EAAE;AAChB,YAAM,OAAO,kBAAkB,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;AACpD,SAAK;AACL,KAAG,CAAC;AACJ,CAAC;AAED;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAAK,IAC7B,OAAO,CAAC,MAAiD;AAC3D,QAAI,OAAO,MAAM,CAAC,IAAI,CAChB,GAAG,CAAC,CAAC,KAAK;AAChB,YAAQ,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,uBAAuB,CAAC,KAAK,CAAC,CAAC;AAC/D,YAAQ,OAAO,CAAC,MAAM,EAAE,KAAK,CAAW,CAAC;AACzC,SAAO,CAAC,CACH,CAAC;AACN,KAAG,CAAC;AACJ,CAAC;AAED;AACA;AACA;AACA;AACA,SAAS,uBAAuB,CAC9B,IAAmC;AAClC,IACD,IAAI,MAAS,EAAE,KAAQ,CAAC;AAC1B,IACE,IAAI,IAAI,YAAY,KAAK,EAAE;AAC7B,QAAI,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC;AAC3B,KAAG;AAAC,SAAK;AACT,QAAI,MAAM,GAAG,IAAI,CAAC;AAClB,KAAG;AACH,IACE,OAAO,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AACzB,CAAC;AAED;AACA;AACA;AACA,MACa,eAAe;AAAG,IAC7B,YAAmB,KAAe,EAAS,OAAgB;AAAI,QAA5C,UAAK,GAAL,KAAK,CAAU;AAAC,QAAQ,YAAO,GAAP,OAAO,CAAS;AAAC,KAAG;AACjE;AAEC;AACE;AAEH;AAAO;AAEH;AAAO;AACE;AAEH;AACV;AACc;AACZ;AACE;AACJ;AAA2B;AACE;AAEvB;AAA2B;AACE;AACE;AAEjC;AACO;AAGD;AAAkB;AAChB;AAAO;AAAgC;AACE;AAKjD;AAA0B;AAAa;AAAa;AAAO;AAInB;AAAS;AAAW;AAAO;AAIpD;AAEjB;AAAO;AAAW;AAIpB;AAAoC;AACrB;AAAS;AAAW;AAChC,IAFD,iBAAiB,CACf,UAAkC,EAClC,IAAiC;AAClC,QACC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CACtB,MAAM,CAAI,UAAU,CAAC,EACrB,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,EAC1B,iBAAiB,CAAC,IAAI,CAAC,CACxB,CAAC;AACN,KAAG;AACH;AAEC;AACE;AAEH;AAAO;AACE;AAEH;AAAO;AACE;AAEH;AAAO;AAEH;AAEf;AACA;AAAO;AACE;AACJ;AAA2B;AACE;AAE5B;AAAgC;AAGf;AACxB;AAAO;AAAwC;AAEnB;AAChB;AAGT;AAEU;AAAiB;AAAa;AAAa;AAAO;AAInB;AAAS;AAAW;AAAO;AAIpD;AAEjB;AAAO;AAAW;AAIpB;AAAoC;AACpB;AAAS;AAAW;AAChC,IAFF,gBAAgB,CACd,UAAkC,EAClC,IAAgC;AACjC,QACC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CACtB,MAAM,CAAI,UAAU,CAAC,EACrB,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,EAC1B,gBAAgB,CAAC,IAAI,CAAC,CACvB,CAAC;AACN,KAAG;AACH;AAEC;AACE;AAEH;AAAO;AAEH;AAAO;AACE;AAEH;AACV;AACc;AACZ;AACE;AACJ;AAA2B;AACE;AAE5B;AAAgC;AAE1B;AACM;AAGN;AAAiB;AACrB;AAAO;AAAqC;AAIzB;AAAa;AAAa;AAAO;AAInB;AAAS;AAAW;AAAO;AAEH;AACzD;AAIF;AAAO;AAAqB;AAAqB;AACrC;AAIX;AAA+B;AAChC;AAAa;AAAO;AACsC;AAClC;AAKf;AACN;AAA0B;AAAiB;AAAc;AAAO;AAEjE;AAGqD;AAA0B;AAElF;AACI;AACE;AAA0F;AAE9F;AAAW;AAAO;AACA;AAAO;AAIhB;AAEX;AAAQ,IAJN,KAAK,CACH,UAAkC,EAClC,IAAqB;AACtB,QACC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CACtB,MAAM,CAAI,UAAU,CAAC,EACrB,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,EAC1B,KAAK,CAAC,IAAI,CAAC,CACZ,CAAC;AACN,KAAG;AACH;AAEC;AACE;AACE;AAEH;AAAO;AAEH;AAAO;AACE;AACE;AAEH;AACV;AACc;AACZ;AACE;AACJ;AAA2B;AAE5B;AAAgC;AAEhC;AACS;AAEC;AAAkB;AACrB;AAAqC;AAEtC;AAGJ;AAA0B;AAAa;AAAa;AAKlC;AACjB;AAAW;AAAQ,IAFvB,UAAU,CACR,SAAoB,EACpB,IAA6B;AAC9B,QACC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CACtB,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,EAC1B,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,CAC5B,CAAC;AACN,KAAG;AACH;2CA9OC,UAAU;6GACT;AAAC;AACO,YAnLO,KAAK;AAAI,YAFjB,OAAO;AAAG;;;gGAAE;AAmarB,SAAS,YAAY,CACnB,SAAoB,EACpB,CAAyB;AACxB,IACD,IAAI,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC,WAAW,CAAC,SAAS,KAAK,SAAS,EAAE;AAC9D,QAAI,OAAO,CAAC,CAAC;AACb,KAAG;AACH,IAAE,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE;AAC9B,QAAI,MAAM,EAAE,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;AAC1C,QAAI,IAAI,EAAE,EAAE;AACZ,YAAM,OAAO,EAAE,CAAC;AAChB,SAAK;AACL,KAAG;AACH,IAAE,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,kBAAkB,CAAI,GAA6B;AAAI,IAC9D,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;AACzB,QAAI,OAAO,GAAG,CAAC;AACf,KAAG;AAAC,SAAK,IAAI,CAAC,GAAG,EAAE;AACnB,QAAI,OAAO,EAAE,EAAE,CAAC;AAChB,KAAG;AAAC,SAAK;AACT,QAAI,OAAO,EAAE,CAAC,GAAQ,CAAC,CAAC;AACxB,KAAG;AACH;AACA;AC3bA;AACA;AACA;AACA;AACA;AACA,MACa,QAAQ;AACrB,IAAE,OAAO,OAAO;AAAK,QACjB,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC,eAAe,CAAC,EAAE,CAAC;AAChE,KAAG;AACH;oCALC,QAAQ,SAAC,EAAE;;;;;0BACP;AAAC;ACTN;AACA;AACA;AACA;AACA;AACqE","sourcesContent":["import { Injectable, Type } from '@angular/core';\nimport { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Actions, ofType } from '@ngrx/effects';\nimport { ROUTER_NAVIGATION, RouterNavigationAction } from '@ngrx/router-store';\nimport { Action, Store, ActionCreator } from '@ngrx/store';\nimport { isObservable, Observable, of } from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  switchMap,\n  withLatestFrom,\n} from 'rxjs/operators';\n\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface PessimisticUpdateOpts<T, A> {\n  run(a: A, state?: T): Observable<Action> | Action | void;\n  onError(a: A, e: any): Observable<any> | any;\n}\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface OptimisticUpdateOpts<T, A> {\n  run(a: A, state?: T): Observable<Action> | Action | void;\n  undoAction(a: A, e: any): Observable<Action> | Action;\n}\n\n/**\n * See {@link DataPersistence.fetch} for more information.\n */\nexport interface FetchOpts<T, A> {\n  id?(a: A, state?: T): any;\n  run(a: A, state?: T): Observable<Action> | Action | void;\n  onError?(a: A, e: any): Observable<any> | any;\n}\n\n/**\n * See {@link DataPersistence.navigation} for more information.\n */\nexport interface HandleNavigationOpts<T> {\n  run(a: ActivatedRouteSnapshot, state?: T): Observable<Action> | Action | void;\n  onError?(a: ActivatedRouteSnapshot, e: any): Observable<any> | any;\n}\n\nexport type ActionOrActionWithState<T, A> = A | [A, T];\nexport type ActionStateStream<T, A> = Observable<ActionOrActionWithState<T, A>>;\n\nexport function pessimisticUpdate<T, A extends Action>(\n  opts: PessimisticUpdateOpts<T, A>\n) {\n  return (source: ActionStateStream<T, A>): Observable<Action> => {\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.onError))\n    );\n  };\n}\n\nexport function optimisticUpdate<T, A extends Action>(\n  opts: OptimisticUpdateOpts<T, A>\n) {\n  return (source: ActionStateStream<T, A>): Observable<Action> => {\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.undoAction))\n    );\n  };\n}\n\nexport function fetch<T, A extends Action>(opts: FetchOpts<T, A>) {\n  return (source: ActionStateStream<T, A>): Observable<Action> => {\n    if (opts.id) {\n      const groupedFetches = source.pipe(\n        mapActionAndState(),\n        groupBy(([action, store]) => {\n          return opts.id(action, store);\n        })\n      );\n\n      return groupedFetches.pipe(\n        mergeMap((pairs) =>\n          pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))\n        )\n      );\n    }\n\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.onError))\n    );\n  };\n}\n\nexport function navigation<T, A extends Action>(\n  component: Type<any>,\n  opts: HandleNavigationOpts<T>\n) {\n  return (source: ActionStateStream<T, A>) => {\n    const nav = source.pipe(\n      mapActionAndState(),\n      filter(([action, state]) => isStateSnapshot(action)),\n      map(([action, state]) => {\n        if (!isStateSnapshot(action)) {\n          // Because of the above filter we'll never get here,\n          // but this properly type narrows `action`\n          return;\n        }\n\n        return [\n          findSnapshot(component, action.payload.routerState.root),\n          state,\n        ] as [ActivatedRouteSnapshot, T];\n      }),\n      filter(([snapshot, state]) => !!snapshot)\n    );\n\n    return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n\nfunction isStateSnapshot(\n  action: any\n): action is RouterNavigationAction<RouterStateSnapshot> {\n  return action.type === ROUTER_NAVIGATION;\n}\n\nfunction runWithErrorHandling<T, A, R>(\n  run: (a: A, state?: T) => Observable<R> | R | void,\n  onError: any\n) {\n  return ([action, state]: [A, T]): Observable<R> => {\n    try {\n      const r = wrapIntoObservable(run(action, state));\n      return r.pipe(catchError((e) => wrapIntoObservable(onError(action, e))));\n    } catch (e) {\n      return wrapIntoObservable(onError(action, e));\n    }\n  };\n}\n\n/**\n * @whatItDoes maps Observable<Action | [Action, State]> to\n * Observable<[Action, State]>\n */\nfunction mapActionAndState<T, A>() {\n  return (source: Observable<ActionOrActionWithState<T, A>>) => {\n    return source.pipe(\n      map((value) => {\n        const [action, store] = normalizeActionAndState(value);\n        return [action, store] as [A, T];\n      })\n    );\n  };\n}\n\n/**\n * @whatItDoes Normalizes either a bare action or an array of action and state\n * into an array of action and state (or undefined)\n */\nfunction normalizeActionAndState<T, A>(\n  args: ActionOrActionWithState<T, A>\n): [A, T] {\n  let action: A, state: T;\n\n  if (args instanceof Array) {\n    [action, state] = args;\n  } else {\n    action = args;\n  }\n\n  return [action, state];\n}\n\n/**\n * @whatItDoes Provides convenience methods for implementing common operations of persisting data.\n */\n@Injectable()\nexport class DataPersistence<T> {\n  constructor(public store: Store<T>, public actions: Actions) {}\n\n  /**\n   *\n   * @whatItDoes Handles pessimistic updates (updating the server first).\n   *\n   * Update the server implemented naively suffers from race conditions and poor error handling.\n   *\n   * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n   *     // provides an action and the current state of the store\n   *     run(a, state) {\n   *       // update the backend first, and then dispatch an action that will\n   *       // update the client side\n   *       return this.backend(state.user, a.payload).map(updated => ({\n   *         type: 'TODO_UPDATED',\n   *         payload: updated\n   *       }));\n   *     },\n   *\n   *     onError(a, e: any) {\n   *       // we don't need to undo the changes on the client side.\n   *       // we can dispatch an error, or simply log the error here and return `null`\n   *       return null;\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * Note that if you don't return a new action from the run callback, you must set the dispatch property\n   * of the effect to false, like this:\n   *\n   * ```\n   * class TodoEffects {\n   *   @Effect({dispatch: false})\n   *   updateTodo; //...\n   * }\n   * ```\n   */\n  pessimisticUpdate<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: PessimisticUpdateOpts<T, A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      pessimisticUpdate(opts)\n    );\n  }\n\n  /**\n   *\n   * @whatItDoes Handles optimistic updates (updating the client first).\n   *\n   * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,\n   * the developer already updated the state locally, so the developer must provide an undo action.\n   *\n   * The error handling must be done in the callback, or by means of the undo action.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload);\n   *     },\n   *\n   *     undoAction: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *       return ({\n   *         type: 'UNDO_UPDATE_TODO',\n   *         payload: a\n   *       });\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * Note that if you don't return a new action from the run callback, you must set the dispatch property\n   * of the effect to false, like this:\n   *\n   * ```\n   * class TodoEffects {\n   *   @Effect({dispatch: false})\n   *   updateTodo; //...\n   * }\n   * ```\n   */\n  optimisticUpdate<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: OptimisticUpdateOpts<T, A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      optimisticUpdate(opts)\n    );\n  }\n\n  /**\n   *\n   * @whatItDoes Handles data fetching.\n   *\n   * Data fetching implemented naively suffers from race conditions and poor error handling.\n   *\n   * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload).map(r => ({\n   *         type: 'TODOS',\n   *         payload: r\n   *       });\n   *     },\n   *\n   *     onError: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * This is correct, but because it set the concurrency to 1, it may not be performant.\n   *\n   * To fix that, you can provide the `id` function, like this:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {\n   *     id: (a, state) => {\n   *       return a.payload.id;\n   *     }\n   *\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload).map(r => ({\n   *         type: 'TODO',\n   *         payload: r\n   *       });\n   *     },\n   *\n   *     onError: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *       return null;\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.\n   *\n   * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,\n   * it will only run the last one.\n   */\n  fetch<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: FetchOpts<T, A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      fetch(opts)\n    );\n  }\n\n  /**\n   * @whatItDoes Handles data fetching as part of router navigation.\n   *\n   * Data fetching implemented naively suffers from race conditions and poor error handling.\n   *\n   * `navigation` addresses these problems.\n   *\n   * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`\n   * callback. It provides the activated snapshot associated with the component and the current state. And it only runs\n   * the last request.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodo = this.s.navigation(TodoComponent, {\n   *     run: (a, state) => {\n   *       return this.backend.fetchTodo(a.params['id']).map(todo => ({\n   *         type: 'TODO_LOADED',\n   *         payload: todo\n   *       }));\n   *     },\n   *     onError: (a, e: any) => {\n   *       // we can log and error here and return null\n   *       // we can also navigate back\n   *       return null;\n   *     }\n   *   });\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   */\n  navigation(\n    component: Type<any>,\n    opts: HandleNavigationOpts<T>\n  ): Observable<any> {\n    return this.actions.pipe(\n      withLatestFrom(this.store),\n      navigation(component, opts)\n    );\n  }\n}\n\nfunction findSnapshot(\n  component: Type<any>,\n  s: ActivatedRouteSnapshot\n): ActivatedRouteSnapshot {\n  if (s.routeConfig && s.routeConfig.component === component) {\n    return s;\n  }\n  for (const c of s.children) {\n    const ss = findSnapshot(component, c);\n    if (ss) {\n      return ss;\n    }\n  }\n  return null;\n}\n\nfunction wrapIntoObservable<O>(obj: Observable<O> | O | void): Observable<O> {\n  if (isObservable(obj)) {\n    return obj;\n  } else if (!obj) {\n    return of();\n  } else {\n    return of(obj as O);\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { DataPersistence } from './data-persistence';\n\n/**\n * @whatItDoes Provides services for enterprise Angular applications.\n *\n * See {@link DataPersistence} for more information.\n */\n@NgModule({})\nexport class NxModule {\n  static forRoot(): ModuleWithProviders<NxModule> {\n    return { ngModule: NxModule, providers: [DataPersistence] };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"]}