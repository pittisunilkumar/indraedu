{"version":3,"file":"data-persistence.d.ts","sources":["data-persistence.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Type } from '@angular/core';\nimport { ActivatedRouteSnapshot } from '@angular/router';\nimport { Actions } from '@ngrx/effects';\nimport { Action, Store, ActionCreator } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface PessimisticUpdateOpts<T, A> {\n    run(a: A, state?: T): Observable<Action> | Action | void;\n    onError(a: A, e: any): Observable<any> | any;\n}\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface OptimisticUpdateOpts<T, A> {\n    run(a: A, state?: T): Observable<Action> | Action | void;\n    undoAction(a: A, e: any): Observable<Action> | Action;\n}\n/**\n * See {@link DataPersistence.fetch} for more information.\n */\nexport interface FetchOpts<T, A> {\n    id?(a: A, state?: T): any;\n    run(a: A, state?: T): Observable<Action> | Action | void;\n    onError?(a: A, e: any): Observable<any> | any;\n}\n/**\n * See {@link DataPersistence.navigation} for more information.\n */\nexport interface HandleNavigationOpts<T> {\n    run(a: ActivatedRouteSnapshot, state?: T): Observable<Action> | Action | void;\n    onError?(a: ActivatedRouteSnapshot, e: any): Observable<any> | any;\n}\nexport declare type ActionOrActionWithState<T, A> = A | [A, T];\nexport declare type ActionStateStream<T, A> = Observable<ActionOrActionWithState<T, A>>;\nexport declare function pessimisticUpdate<T, A extends Action>(opts: PessimisticUpdateOpts<T, A>): (source: ActionStateStream<T, A>) => Observable<Action>;\nexport declare function optimisticUpdate<T, A extends Action>(opts: OptimisticUpdateOpts<T, A>): (source: ActionStateStream<T, A>) => Observable<Action>;\nexport declare function fetch<T, A extends Action>(opts: FetchOpts<T, A>): (source: ActionStateStream<T, A>) => Observable<Action>;\nexport declare function navigation<T, A extends Action>(component: Type<any>, opts: HandleNavigationOpts<T>): (source: ActionStateStream<T, A>) => Observable<Action>;\n/**\n * @whatItDoes Provides convenience methods for implementing common operations of persisting data.\n */\nexport declare class DataPersistence<T> {\n    store: Store<T>;\n    actions: Actions;\n    constructor(store: Store<T>, actions: Actions);\n    /**\n     *\n     * @whatItDoes Handles pessimistic updates (updating the server first).\n     *\n     * Update the server implemented naively suffers from race conditions and poor error handling.\n     *\n     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n     * and forces the developer to handle errors.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * @Injectable()\n     * class TodoEffects {\n     *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n     *     // provides an action and the current state of the store\n     *     run(a, state) {\n     *       // update the backend first, and then dispatch an action that will\n     *       // update the client side\n     *       return this.backend(state.user, a.payload).map(updated => ({\n     *         type: 'TODO_UPDATED',\n     *         payload: updated\n     *       }));\n     *     },\n     *\n     *     onError(a, e: any) {\n     *       // we don't need to undo the changes on the client side.\n     *       // we can dispatch an error, or simply log the error here and return `null`\n     *       return null;\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * Note that if you don't return a new action from the run callback, you must set the dispatch property\n     * of the effect to false, like this:\n     *\n     * ```\n     * class TodoEffects {\n     *   @Effect({dispatch: false})\n     *   updateTodo; //...\n     * }\n     * ```\n     */\n    pessimisticUpdate<A extends Action = Action>(actionType: string | ActionCreator, opts: PessimisticUpdateOpts<T, A>): Observable<any>;\n    /**\n     *\n     * @whatItDoes Handles optimistic updates (updating the client first).\n     *\n     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n     * and forces the developer to handle errors.\n     *\n     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,\n     * the developer already updated the state locally, so the developer must provide an undo action.\n     *\n     * The error handling must be done in the callback, or by means of the undo action.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * @Injectable()\n     * class TodoEffects {\n     *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n     *     // provides an action and the current state of the store\n     *     run: (a, state) => {\n     *       return this.backend(state.user, a.payload);\n     *     },\n     *\n     *     undoAction: (a, e: any) => {\n     *       // dispatch an undo action to undo the changes in the client state\n     *       return ({\n     *         type: 'UNDO_UPDATE_TODO',\n     *         payload: a\n     *       });\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * Note that if you don't return a new action from the run callback, you must set the dispatch property\n     * of the effect to false, like this:\n     *\n     * ```\n     * class TodoEffects {\n     *   @Effect({dispatch: false})\n     *   updateTodo; //...\n     * }\n     * ```\n     */\n    optimisticUpdate<A extends Action = Action>(actionType: string | ActionCreator, opts: OptimisticUpdateOpts<T, A>): Observable<any>;\n    /**\n     *\n     * @whatItDoes Handles data fetching.\n     *\n     * Data fetching implemented naively suffers from race conditions and poor error handling.\n     *\n     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions\n     * and forces the developer to handle errors.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * @Injectable()\n     * class TodoEffects {\n     *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {\n     *     // provides an action and the current state of the store\n     *     run: (a, state) => {\n     *       return this.backend(state.user, a.payload).map(r => ({\n     *         type: 'TODOS',\n     *         payload: r\n     *       });\n     *     },\n     *\n     *     onError: (a, e: any) => {\n     *       // dispatch an undo action to undo the changes in the client state\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * This is correct, but because it set the concurrency to 1, it may not be performant.\n     *\n     * To fix that, you can provide the `id` function, like this:\n     *\n     * ```typescript\n     * @Injectable()\n     * class TodoEffects {\n     *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {\n     *     id: (a, state) => {\n     *       return a.payload.id;\n     *     }\n     *\n     *     // provides an action and the current state of the store\n     *     run: (a, state) => {\n     *       return this.backend(state.user, a.payload).map(r => ({\n     *         type: 'TODO',\n     *         payload: r\n     *       });\n     *     },\n     *\n     *     onError: (a, e: any) => {\n     *       // dispatch an undo action to undo the changes in the client state\n     *       return null;\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.\n     *\n     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,\n     * it will only run the last one.\n     */\n    fetch<A extends Action = Action>(actionType: string | ActionCreator, opts: FetchOpts<T, A>): Observable<any>;\n    /**\n     * @whatItDoes Handles data fetching as part of router navigation.\n     *\n     * Data fetching implemented naively suffers from race conditions and poor error handling.\n     *\n     * `navigation` addresses these problems.\n     *\n     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`\n     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs\n     * the last request.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * @Injectable()\n     * class TodoEffects {\n     *   @Effect() loadTodo = this.s.navigation(TodoComponent, {\n     *     run: (a, state) => {\n     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({\n     *         type: 'TODO_LOADED',\n     *         payload: todo\n     *       }));\n     *     },\n     *     onError: (a, e: any) => {\n     *       // we can log and error here and return null\n     *       // we can also navigate back\n     *       return null;\n     *     }\n     *   });\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     */\n    navigation(component: Type<any>, opts: HandleNavigationOpts<T>): Observable<any>;\n}\n"]}